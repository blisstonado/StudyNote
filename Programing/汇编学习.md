1. 课程概述 

   https://www.youtube.com/watch?v=6pg2TCSI4PM
   1. 什么是机器语言？
      * 加：0100 0000
      * 减：0100 1000
      * 乘：1111 0111 1110 0000
      * 除：1111 0111 1111 0000
   2. 什么是汇编语言？
      * 加：INC EAX  ---编译器---> 0100 0000
      * 减：DEC EAX  ---编译器---> 0100 1000
      * 乘：MUL EAX  ---编译器---> 1111 0111 1110 0000
      * 除：DIV EAX  ---编译器---> 1111 0111 1111 0000
   3. 什么是C语言？
      * 加：A + B  ---编译器---> 0100 0000
      * 减：A - B  ---编译器---> 0100 1000
      * 乘：A * B  ---编译器---> 1111 0111 1110 0000
      * 除：A / B  ---编译器---> 1111 0111 1111 0000
   4. C语言和C++的关系？
      * c和c++其实没有本质区别，只是编译器做的事情更多了，更强大了
      * c是学好c++的基础
   5. 为什么要学汇编语言？
2. 进制
   1. 学习进制的障碍：
      很多人学不好进制，原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换成十进制，这种学习方法是错误的。
      我们为什么一定要转换进制呢？仅仅是因为我们对十进制最属虚，所以才转换。
      <font color=red>每一种进制都是完美的，想学好进制首先要忘掉十进制，也要忘掉进制间的转换</font>
   2. 进制的定义：
      1. 1进制：
         * 由1个符号组成，该符号为：0， 逢0进1，类似于结绳记事
         * 用1进制表示0-19：
         ``` 
         0
         00
         000
         0000
         00000
         ... ... 
         0000000000000000000
         ```
        
      2. 3进制
         * 由3个符号组成，符号为0、1、2，逢2进1
         * 用3进制表示0-19
         ```
         0
         1
         2
         10
         11
         12
         20
         21
         22
         100
         101
         102
         110
         111
         112
         120
         121
         122
         200
         201
         ```
      3. 7进制
         * 由7个符号组成，符号为0、1、2、3、4、5、6，逢6进1
         * 用7进制表示0-19
         ```
         0
         1
         2
         3
         4
         5
         6
         10
         11
         12
         13
         14
         15
         16
         20
         21
         22
         23
         24
         25
         ```
      4. 你理解进制了吗？1+1=3对吗？
   3. 进制的运算
      1. 8进制运算
         * 2 + 3 = ? 2 * 3 = ? 4 + 5 = ? 4 * 5 = ?
         * 277 + 333 = ? 236 - 54 = ? 237 * 54 = ? 234 / 4 = ?
         * 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27 30 ...
      2. 8进制加法表
      ```
      1+1=2
      1+2=3  2+2=4
      1+3=4  2+3=5  3+3=6
      1+4=5  2+4=6  3+4=7  4+4=10
      1+5=6  2+5=7  3+5=10 4+5=11 5+5=12
      1+6=7  2+6=10 3+6=11 4+6=12 5+6=13 6+6=14
      1+7=10 2+7=11 3+7=12 4+7=13 5+7=14 6+7=15 7+7=16
      ```
      3. 8进制乘法表
      ```
      1*1=1  
      1*2=2  2*2=4 
      1*3=3  2*3=6  3*3=11
      1*4=4  2*4=10 3*4=14 4*4=20
      1*5=5  2*5=12 3*5=17 4*5=24 5*5=31 
      1*6=6  2*6=14 3*6=22 4*6=30 5*6=36 6*6=44
      1*7=7  2*7=16 3*7=25 4*7=34 5*7=43 6*7=52 7*7=61

      ```
      4. 现在来算上面的加减乘除
      ```
       277      236     276     234
      +333     - 54    * 54    /  4
      -----   ------  ------  ------
       632      162     1370     47
                       1666 
                      ------
                       20250 
      ```
   4. 为什么计算机使用二进制？因为电路只有2种状态
   5. 2进制和16进制之间的关系,16进制其实是2进制的一种简写
      ```
      0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
      ```
3. 数据宽度
   1. 计算机种常见的数据宽度
      * 位 bit
      * 字节 byte
      * 字 word
      * 双字 double word
   2. 存储范围
      * 字节 byte: 0 ~ 0xFF
      * 字  word: 0 ~ 0xFFFF
      * 双字 dword:0 ~ 0xFFFFFFFF
   3. 有符号数的编码规则
      1. 原码：最高位位符号位，其余各位为数值本身的绝对值
      2. 反码：
         * 正数：反码与原码相同
         * 负数：符号位为1，其余位对原码取反
      3. 补码：
         * 正数：补码与原码相同
         * 负数：符号位为1，其余位对原码取反+1
   4. 无符号的数编码规则
      1. 原码-》反码-》补码
      2. -7存储
         1. -7的原码：1000 0111
         2. -7的反码：1111 1000
         3. -7的补码：1111 1001 = F9
         4. 验证，vc++6，查看内存地址中的值
       ```c 
       char x = -7;
       printf("%x\n", &x);
       return 0;
       ```
      3. FF是有符号的几？
         1. 1111 1111还原反码：1111 1110
         2. 1111 1110还原原码：1000 0001
         3. FF为 -1
4. 计算机不会四则运算，只会位运算      
   1. 位运算
      1. 与运算
      2. 或运算
      3. 异或运算：不一样的时候是1
      4. 非运算
      5. 左移：各二进制位全部左移若干位，高位丢弃，低位补0
         1. 1101 1000 左移2位：0110 0000
      6. 右移：各二进制位全部右移若干位，低位丢弃，高位补0或者补符号位
         1. 汇编中：shr 补0， sar补符号位
         2. c语言中：无符号补0，有符号的补符号位
         2. 1101 0101 右移2位：0011 0101
   2. 计算机如何实现加法
   3. 计算机如何实现减法
5. 汇编语言环境搭建
   1. DTDebug
   2. 环境配置
      1. Appearance -> udd path , plugin path
6. 寄存器
   1. 32位通用寄存器
      * EAX ECX EDX EBX
      * ESP EBP ESI EDI 
   2. MOV指令
      * 立即数到寄存器
      * 寄存器到寄存器
   3. 其他通用寄存器
      ```
      32位   16位   8位
      EAX    AX    AL
      ECX    CX    CL
      EDX    DX    DL
      EBX    BX    BL
      ESP    SP    AH
      EBP    BP    CH
      ESI    SI    DH
      EDI    DI    BH
      ```
7. 内存
   1. 每个应用程序都会有自己的独立4g内存空间
   2. 内存地址
      1. 内存太大没办法起名字，只用用编号
      2. 编号称为内存地址（32位，前面0可以省略）
   3. MOV指令
      1. 立即数到内存
         * MOV BYTE PTR DS:[内存地址], 立即数
      2. 寄存器到内存
         * MOV DWORD PTR DS:[内存地址], EAX
      3. 内存到寄存器
         * MOV EAX, DWORD PTR DS:[内存地址]
   4. 内存读写的5种形式
      1. 形式1:[立即数]
         1. 读取内存的值：
            * MOV EAX, DWORD PTR DS:[0X13FFC4]
         2. 向内存中写入数据：
            * MOV DWORD PTR DS:[0X13FFC4], EAX
      2. 形式2:[reg] reg代表寄存器，可以是8个通用寄存器中的任意一个
         1. 读取内存的值
            * MOV ECX, 0X13FFDO
            * MOV EAX, DWORD PTR DS:[ECX]
         2. 向内存中写数据
            * MOV EAX, 0X13FFD0
            * MOV DWORD PTR DS:[EAX], 0X123456
      3. 形式3:[ret + 立即数]
         1. 读取内存
            * MOV ECX, 0X13FFD0
            * MOV EAX, DWORD PTR DS:[ECX+4]
         2. 写内存
            * MOV EDX, 0X13FFD8
            * DWORD PTR DS:[EDX+0XC], 0X87654321
      4. 形式4:[reg + reg * {1,2,4,8}]
         1. 读内存
            * MOV EAX, 13FFC4
            * MOV ECX, 2
            * MOV EDX, DWORD PTR DS:[EAX + ECX * 4]
         2. 写内存
            * MOV EAX, 13FFC4
            * MOV ECX, 2
            * MOV DWORD PTR DS:[EAX + ECX * 4], 87654321
      5. 形式5:[reg + reg * {1, 2, 4, 8} + 立即数]
         1. 读内存
            * MOV EAX, 13FFC4
            * MOV ECX, 2
            * MOV EDX, DWORD PTR DS:[EAX + ECX * 4 + 4]
         2. 写内存
            * MOV EAX, 13FFC4
            * MOV ECX, 2
            * MOV DWORD PTR DS:[EAX + ECX * 4 + 4], 87654321
8. 数据的存储模式
   1. 存储方式
      * 大端模式：高位存储在低位，低位存储在高位
      * 小端模式：低位存储在低位，高位处处在高位
   2. DTDEBUG内存窗口的使用
      1. 分别以字节、字、双字形式来查看内存
      2. 向内存写入4个字节数据，并观察存储形式
9. 常用汇编指令
   1. MOV
   2. ADD
   3. SUB
   4. AND
   5. OR
   6. XOR
   7. NOT
   8. MOVS 移动数据 内存-内存
      1. 用法
         * MOVS BYTE PTR ES:[EDI], BYTE PTR DS:[ESI]     简写：MOVSB
         * MOVS WORD PTR ES:[EDI], BYTE PTR DS:[ESI]     简写：MOVSW
         * MOVS DWORD PTR ES:[EDI], BYTE PTR DS:[ESI]    简写：MOVSD
         
         把eis中内存地址中的值移动到edi内存地址中，EDI和ESI中保存的是地址编号，每执行一次EDI和ESI都会+1
      2. 例子
         * MOV EDI, 12FFD8
         * MOV ESI, 12FFD0
         * MOVS DWORD PTR ES:[EDI] DWORD PTR DS[ESI]     观察EDI的值
      3. 标志寄存器 EFL, 
         * EFL是32位，其中第10位是DF方向位：如果为0的话movs执行一次ESI和EDI就+（1,2,4)，如果为1的话movs执行一次ESI和EDI就-(1,2,4)
   9. STOS 将AL/AX/EAX的值存储到[EDI]指定的内存单元
      1. 用法
         * STOS BYTE PTR ES:[EDI]    简写：STOSB
         * STOS WORD PTR ES:[EDI]    简写：STOSW
         * STOS DWORD PTR ES:[EDI]   简写：STOSD
      2. 例子
         * MOV EAX, 12345678
         * MOV EDI, 12FFC4
         * STOS BYTE PTR ES:[EDI]
         * STOS WORD PTR ES:[EDI]
         * STOS DWORD PTR ES:[EDI]
         * 修改标志寄存器d位的值，然后在执行下面的指令
         * MOV EAX, 12345678
         * MOV EDI, 12FFC4
   10. REP 按技术寄存器（ECX）中指定的次数重复执行字符串指令
       1. 用法
          * MOV ECX,10
          * REP MOVSD
          * REP STOSD
       2. 例子
10. 堆栈
    1. ESP 栈指针寄存器
    2. 栈的使用
       1. 存储数据
       2. 修改栈顶指针
    3. PUSH 
       1. 功能
          1. 向堆栈中压入数据
          2. 修改栈顶指针esp寄存器
       2. 指令格式
    4. pop
       1. 功能
          1. 将栈顶数据存储到寄存器/内存
          2. 修改栈顶指针到eps寄存器
11. 修改EIP的指令
    EIP中存的值是cup下一次要执行的地址
    ```
    操作码        说明               参考标志位
    JE/JZ    运算结果相等/为0跳转      zf=1
    JNE/JNE  运算结果不相等/不为0跳转   zf=0
    JS       运算结果为负跳转          sf=1
    JNS      运算结果为正跳转          sf=0
    JP/JPE   运算结果1的个数为偶数跳转   pf=1
    JNP/JPO  运算结果1的个数为奇数跳转   pf=0
    JO       运算结果产生溢出          of=1
    JNO      运算结果无溢出            of=0
    JB/JNAE/JC 无符号数比较,小于跳转          cf=1
    JNB/JAE/JNC 无符号数比较，大于等于跳转     cf=0
    JBE/JNA  有符号数比较小于等于跳转   zf=1 或 cf=1
    JNBE/JA  大于跳转（无符号数）      zf=0 或 cf=0
    JL/JNGE  若小于则跳转（有符号）    sf != of
    JNL/JGE  大于等于跳转（有符号）    sf = of
    JLE/JNG  小于等于跳转（有符号）    sf!=of 或 zf=1
    JNLE/JG  大于跳转（有符号数）     sf=of 且 zf=0
    ```
    1. JMP
       * MOV EIP 寄存器/立即数/内存 简写为 JMP 寄存器/立即数/内存
       * JMP 就是修改EIP的值
    2. CALL
       * PUSH 下一行地址 MOV EIP, 寄存器/立即数/内存 简写为：CALL 寄存器/立即数/内存
       * <font color=red>与JMP唯一的区别：在堆栈中存储CALL指令的下一行地址</font> 
       * 理解：调用call时，首先把call当前指令的下一条指令放入栈中，esp栈寄存器-4，然后eip的值改为call指令指定的地址。
    3. RET
       * ADD ESP, 4
       * MOV EIP, [ESP-4]  简写为 RET
12. 汇编函数
    1. 什么是函数 一系列指令集合，为了完成某个会重复使用的特定功能
    2. 例子
      1. 向寄存器中赋值
    3. 如何执行一个函数？函数调用
       1. JMP来执行函数
       2. CALL来执行函数
    4. 什么是参数？什么是返回值？
       1. 例子：编写一个函数，能够得到任意2个整数相加的值
       ```
       004002A0   MOV ECX,1
       004002A5   MOV EDX,3
       004002AF   CALL 004002BC
       ... ...
       004002BC   ADD ECX, EDX
       004002BE   MOV EAX, ECX
       004002C0   RETN
       ```
    5. 堆栈传参
       1. 例子：4个数相加
       ```
        0040029F    PUSH 1
        004002A2    PUSH 2
        004002A4    PUSH 3
        004002A6    PUSH 4
        004002A8    CALL 004002D2
        ... ...
        004002D2    MOV EAX, DWORD PTR DS:[ESP+10]
        004002D7    ADD EAX, DWORD PTR DS:[ESP+C]
        004002DC    ADD EAX, DWORD PTR DS:[ESP+8]
        004002E1    ADD EAX, DWORD PTR DS:[ESP+4]
        004002E6    RETN 8
       ```
       2. 什么是堆栈平衡
          1. 如果要返回父程序，则当我们在堆栈中进行堆栈的操作时，一定要保证在ret这条指令之前，esp指向的是我们压入栈中的地址。
          2. 如果通过堆栈传递参数，那么在函数执行完后，要平衡参数导致的堆栈变化
13. ESP寻址 EBP寻址
    1. 例子
    ```
     004002A2     PUSH 1
     004002A4     PUSH 2
     004002A6     CALL 004002C0
     ... ...
     004002C0     PUSH EBP                       // EBP入栈
     004002C1     MOV EBP, ESP                   // 让栈底指向栈顶
     004002C3     SUB ESP, 10                    // 提升栈顶
     004002C6     MOV EAX, DWORD PTR DS:[EBP+8]  // 取第1个参数
     004002CA     ADD EAX, DWORD PTR DS:[EBP+C]  // 取第2个参数
     004002CE     MOV ESP, EBP                   // 让栈顶指向栈底
     004002D0     POP EBP                        // 恢复栈底
     004002D1     RETN 8                         // 内平栈
    
    ```
14. JCC
    1. 标志寄存器 EFLAGS
    ```
    31  ...  22  21  20  19  18  17  16  15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
         0                                0              OF  DF  IF  TF  SF  ZF   0  AF   0  PF   1  CF
    
    ```
    2. CF Carry flag
       1. 若算数操作产生的结果在最高位的有效位(most-significant bit)发生进位或借位则将其置1，反之清零
       2. 这个标志通常用来指示无符号整型运算的溢出状态
       3. 例子
          * 溢出：MOV AL, 0xFE  ADD AL, 2
          * 借位：MOV AL, 0x7F  SUB AL, 0xFF
    3. PF Parity flag
       1. 如果结果的最低有效字节(least-significant)包含偶数个1位则该位置1，否则清零。
       2. 利用PF可进行奇偶校验检查
       3. 需要传输"11001110"，数据中含5个1，所以其校验位为"0"，同时把"110011100"传输给接收方，接收方收到数据后再一次计算奇偶性，"110011100"中仍然含有5个1，所以接收方计算出的奇校验位还是0，与发送方一致，表示在此次传输过程中未发生错误
       4. 例子
    4. AF Adjuest flag
    5. ZF Zero flag
       1. 结果为0则置1，反之清零
       2. 经常与cmp或test一起使用
       3. 例子：
          1. 判断2个值是否相等
             * MOV EAX, 100; MOV ECX, 100; CMP EAX, ECX
             * CMP指令相当于sub指令，但是相减的结果并不保存到第一个操作数中
          2. 判断某个值是否为0
             * TEST EAX, EAX
             * TEST相当于AND指令，但是与的结果不会保存到第一个操作数中
       4. SF Sign flag
          1. 该标志被设置为有符号整型的最高有效位 0指示为正，反之则为负
       5. OF Overflow flag
          1. 溢出标志OF用于反映有符号数加减运算所得结果是否溢出
          2. 可以这样理解
             * 如果是无符号数运算，是否溢出看CF位
             * 如果是有符号运算，是否溢出看OF位
       6. DF Direction Flag
          1. 这个方向标志控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)设置DF标志使得串指令自动递减（从搞地址向低地址方向处理字符串），清楚该标志则使得串指令自动递增。
          2. STD以及CLD指令分别用于设置以及清除DF标志
15. 堆栈图
16. c++函数调用约定
    1. _cdcall: 
       1. 特点：
          1. push参数，顺序从右往左
          2. 外平栈
    2. _stdcall:
       1. 特点：
          1. push参数，顺序从右往左
          2. 内平栈
    3. _fastcall:
       1. 特点：
          1. 寄存器传参, edx, dcx
          2. 内平栈
17. 找函数main函数
    1. 函数入口特征：push ebp; mov ebp, esp;
    2. 回推法：在自己的程序中找到main地址，然后回推。
       1. 调用call的时候，会把call的下一条指令压入堆栈，找到函数的ebp，ebp+4就是call的下一条指令的地址（函数的返回地址）
       2. 进入函数，找到ebp+4，在堆栈窗口按回车，进入上一个函数
18. swtich分析
    1. 当case调笑小于3个的时候，跟if一样
    2. 当case条件大于3个的时候并且每个case数字是挨着的，switch语句会生成一个地址表，通过一个公式获取到地址的索引，减去case的最小值，与最大值， 最小值的差进行比较
    2. 如果case之间相差的数比较少的话，他的地址表会用default地址填充
    4. 如果相差很多，他就进行了一个变通，他又添加了一张表，表用来存放索引
    5. 如果隔的太远，完全不连续，跟if一样
